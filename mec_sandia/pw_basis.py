"""
Construct a PW basis for square unit cells
"""
import itertools
from qcpanop.pw_pbc.basis import plane_wave_basis # this is a class
import numpy as np
from pyscf.lib.numpy_helper import cartesian_prod

def factor_integer(n):

    i = 2
    factors=[]
    while i*i <= n:

        if n % i:
            i += 1
        else:
            n //= i
            if i not in factors:
                factors.append(i)

    if n > 1:
        if n not in factors:
            factors.append(n)

    return factors


class SphericalCutoffPlanewaves:

    def __init__(self, cell_dim: np.ndarray, cutoff_energy):
        """
        Generate a set of momenta below a spherical cutoff

        :param cell_dim: cell dimension in bohr
        :param cutoff_energy: cutoff energy (in Hartree) 
        """
        self.a = cell_dim
        self.b = 2 * np.pi * np.linalg.inv(self.a)
        self.Omega = np.linalg.det(self.a)
        self.cutoff_energy = cutoff_energy

    @staticmethod
    def ke_cuttoff_to_grid(ke_cutoff, a, b):
        """
        Generate Miller indices, mometa (wavenumbers), reciprocal grids, and real-space grid dimensions 
        """
        cell_vol = np.linalg.det(a)
        reciprocal_max_dim_1 = int( np.ceil( (np.sqrt(2.0*4.0*ke_cutoff) / (2.0 * np.pi) ) * cell_vol**(1/3) + 1.0))
        reciprocal_max_dim_2 = int( np.ceil( (np.sqrt(2.0*4.0*ke_cutoff) / (2.0 * np.pi) ) * cell_vol**(1/3) + 1.0))
        reciprocal_max_dim_3 = int( np.ceil( (np.sqrt(2.0*4.0*ke_cutoff) / (2.0 * np.pi) ) * cell_vol**(1/3) + 1.0))

        # get grid integer range
        dim_1_grid = np.arange(-reciprocal_max_dim_1, reciprocal_max_dim_1+1)
        dim_2_grid = np.arange(-reciprocal_max_dim_2, reciprocal_max_dim_2+1)
        dim_3_grid = np.arange(-reciprocal_max_dim_3, reciprocal_max_dim_3+1)

        ijk_idx = cartesian_prod([dim_1_grid, dim_2_grid, dim_3_grid])
        possible_g_vals = ijk_idx.dot(b.T)
        g2vals = np.sum(np.multiply(possible_g_vals, possible_g_vals), axis=-1)

        gidx_below_ke_cutoff = np.where(g2vals / 2 <= ke_cutoff)[0]
        assert all(g2vals[gidx_below_ke_cutoff] / 2 <= ke_cutoff)

        miller_indices = ijk_idx[gidx_below_ke_cutoff, :]
        g_vals = possible_g_vals[gidx_below_ke_cutoff, :]

        # reciprocal_max_dim contains the maximum dimension for reciprocal basis
        reciprocal_max_dim = [int(np.amax(miller_indices[:, 0])), int(np.amax(miller_indices[:, 1])), int(np.amax(miller_indices[:, 2]))]

        # real_space_grid_dim is the real space grid dimensions
        real_space_grid_dim = [2 * reciprocal_max_dim[0] + 1, 2 * reciprocal_max_dim[1] + 1, 2 * reciprocal_max_dim[2] + 1]

        #increment the size of the real space grid until it is FFT-ready (only contains factors of 2, 3, or 5)
        for i in range( len(real_space_grid_dim) ):
            while np.any(np.union1d( factor_integer(real_space_grid_dim[i]), (2, 3, 5)) != (2, 3, 5)):
                real_space_grid_dim[i] += 1

        return g_vals, miller_indices, reciprocal_max_dim, real_space_grid_dim


class SquareBoxPlanewaves:

    def __init__(self, cell_dim: np.ndarray, nx_grid: int):
        """
        :param cell_dim: cell dimensions in bohr. This should be a diagonal matrix where all elements along the diagonal 
                         are identical
        :param int nx_grid: number of grid points in one-spatial dimension. This must be power of 2 and is exactly N^{1/3}
                            number of planewaves used in the calculation. all momentum are thus generated by 
                            product(np.arange(-nx_grid/2, nx_grid/2), repeat=3) * 2 * np.pi / vol**(1/3)
        """
        if not np.isclose(2**np.log2(nx_grid), nx_grid):
            raise ValueError("nx_grid must be a power of 2")
        
        self.a = cell_dim
        self.b = 2 * np.pi * np.linalg.inv(self.a)
        self.Omega = np.linalg.det(self.a)
        self.nx_grid = nx_grid
        self.N = nx_grid * nx_grid * nx_grid 
        self.np = np.ceil(np.log2(nx_grid) + 1) # one extra bit for sign
        # max_dim = int(np.ceil(np.sqrt(4 * 2 * cell.ke_cutoff) / (2 * np.pi) * cell_vol**(1/3) + 1))
        self.ke_cutoff = 3 * self.nx_grid**2 * 2 * np.pi**2 / self.Omega**(2/3) # this is cutoff in a.u. p = [nx_grid, nx_grid, nx_grid] so 2 * np.pi**2 * 3 * nx_grid**2 / Omega**(2/3)

        self.ke_cutoff_ev = self.ke_cutoff * 27.21138602

        # only generate once per instantiation
        self.kp_basis = None
        self.ke_diagonal = None
        self.p_basis = None
        self.G0_basis = None
    
    def get_p_basis(self, ):
        """Return integers |p> for each register

        satisfying k_p = (2pi/Omega^{1/3}) * p  where p in 0.5 *[-Nx-1, Nx-1]
        """
        if self.p_basis is None:
            self.p_basis = np.array(list(itertools.product(np.arange(-(self.nx_grid)/2, (self.nx_grid)/2, dtype=int), repeat=3)))
            return self.p_basis
        else:
            return self.p_basis
 
    def get_kp_basis(self,):
        if self.kp_basis is None:
            self.kp_basis = 2 * np.pi * self.get_p_basis() / self.Omega**(1/3)
            return self.kp_basis
        else:
            return self.kp_basis
    
    def get_ke_diagonal_values(self,mass=1):
        if self.ke_diagonal is None:
            self.ke_diagonal = np.sum(self.kp_basis**2, axis=-1) / (2 * mass)
            return self.ke_diagonal
        else:
            return self.ke_diagonal
   
    def get_G0_basis(self):
        if self.G0_basis is None:
            nu_x = np.arange(-self.nx_grid, self.nx_grid, dtype=int)
            self.G0_basis = np.array(list(filter(lambda x: not np.allclose(x, [0, 0, 0]), list(itertools.product(nu_x, repeat=3)))))
            return self.G0_basis
        else:
            return self.G0_basis
       

if __name__ == "__main__":
    from mec_sandia.vasp_utils import read_vasp
    from mec_sandia.vasp_utils import compute_wigner_seitz_radius
    from pyscf.pbc import gto
    import pyscf.pbc.tools.pyscf_ase as pyscf_ase
    import numpy as np

    ase_cell = read_vasp(f"vasp_data/D_POSCAR")  # this data is in Angstrom
    atom = pyscf_ase.ase_atoms_to_pyscf(ase_cell)

    deuterium_a = np.array([[8.325876, 0.      , 0.      ],
                            [0.      , 8.325876, 0.      ],
                            [0.      , 0.      , 8.325876]]) * 1.889726124914664 # convert to Bohr

    cell = gto.M(a=ase_cell.cell.array,
                 atom = atom,
                 basis = 'gth-szv',
                 pseudo = 'gth-pade',
                 unit='angstrom',
                 verbose = 0,
                 ke_cutoff = 1000 / 27.21138602, # in atomic units. This would be 10 eV in atomic units
                 precision = 1.0e-8,
                 charge = 0,
                 spin = 1,
                 dimension = 3)

    cell_vol = np.linalg.det(cell.lattice_vectors())
    b = cell.reciprocal_vectors()
    for i, j, k in itertools.product(range(9), repeat=3):
        # G-vector
        gtmp = i * b[0] + j * b[1] + k * b[2]
        assert np.allclose(gtmp, [i * 2* np.pi / cell_vol**(1/3), j * 2* np.pi / cell_vol**(1/3), k * 2* np.pi / cell_vol**(1/3), ])
        # |G|^2
        g2tmp = np.dot(gtmp, gtmp)
        # ke_cutoff for density is 4 times ke_cutoff for orbitals
        if (g2tmp/2.0 <= 4.0 * cell.ke_cutoff):
            # print(g2tmp/2, i, j, k)
            # print(g2tmp/2, 2 * np.pi**2 * (i**2 + j**2 + k**2) / cell_vol**(2/3))
            assert np.isclose(g2tmp/2, 2 * np.pi**2 * (i**2 + j**2 + k**2) / cell_vol**(2/3))
    

    #E = (1/2) * (px**2 + py**2 + pz**2) * 4 * np.pi**2 / cell_vol**(2/3))
    # max in direction = sqrt(4 * 2 * E) = sqrt(px**2 + py**2 + pz**2) * 2 * np.pi / cell_vol**(1/3)
    # sqrt(px**2 + py**2 + pz**2) = |g| norm g.
    max_dim = int(np.ceil(np.sqrt(4 * 2 * cell.ke_cutoff) / (2 * np.pi) * cell_vol**(1/3)))

    reciprocal_max_dim_1 = int( np.ceil( (np.sqrt(2.0*4.0*cell.ke_cutoff) / (2.0 * np.pi) ) * cell_vol**(1/3)))
    inst = SphericalCutoffPlanewaves(cell_dim=cell.lattice_vectors(), cutoff_energy=1000 / 27.21138602 )
    inst.ke_cuttoff_to_grid(inst.cutoff_energy, inst.a, inst.b)